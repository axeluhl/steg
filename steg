#!/bin/bash

# Defaults:
RATIO_OF_CAPACITY_TO_USE=0.8
directory=.
encryption_algorithm=rijndael-256
input_filename=-
mode="embed"
find_files() {
  directory="$1"
  if [ -z "${directory}" ]; then
    directory=.
  fi
  find ${directory} -type f \( -iname '*.jpg' -o -iname '*.jpeg' \) | sort
}

get_file_capacity_in_bytes() {
  echo "Trying to get capacity in bytes of ${1}" >&2
  kB=$( steghide info -p '' "${1}" 2>/dev/null | grep capacity | sed -e 's/.*capacity: *\([0-9.]*\) KB.*$/\1/' )
  # divide capacity reported by two; it often doesn't seem to fit
  echo "${kB} * 1024 * ${RATIO_OF_CAPACITY_TO_USE}" | bc | sed -e 's/\..*$//'
}

get_file_capacity_in_kilobytes() {
  steghide info -e rijndael-256 -p "" "$1" 2>/dev/null | grep capacity | sed -e 's/.*capacity: *\([0-9]*\)\(\.[0-9]*\)\? KB.*$/\1/'
}

get_file_size_in_bytes() {
  wc -c "${1}" | while read size filename; do echo "${size}"; done
}

clean_up() {
  echo "Cleaning up..." >&2
  if [ -n $tmpfile ]; then
    rm "${tmpfile}" 2>/dev/null
  fi
}

show_usage() {
  echo "Usage: $0 [ -x ] [ -d <directory-with-cover-files> ] [ -p <passphrase> ] [ -e <encryption-algorithm> ] [ -h ] [ <embed-file> ]"
  echo
  echo "If -x is provided, extracts a file from the cover files; otherwise, the <embed-file> or standard input"
  echo "will be embedded into the cover files in place, modifying one or more of the cover files."
  echo "To see the list of available encryption algorithms call \"steghide encinfo\"."
  echo "If a directory is provided using -d, all JPEG/jpeg/JPG/jpg files are listed and sorted by path and"
  echo "the files will be used in that order as cover files to extract or embed the content of the embed file. If no"
  echo "directory is provided with -d, the cover files will be searched recursively, starting from the current directory."
  echo "If no <embed-file> is provided, the standard input will be embedded, or extraction will go to standard output, respectively."
  echo "If no passphrase is provided using the -p parameter, the tool will prompt for one."
  echo "Progress output goes to standard error."
  echo "The program exits with code 0 in case all went well; 1 in case there was input left that did not"
  echo "fit into the cover file(s), and 2 if this usage hint was requested."
  echo "Request this usage hint by invoking with -h or without any arguments."
}

# Check for help scenario:
if [ $# = 0 ]; then
  show_usage
  exit 2
fi
# Parsing options:
options=':d:p:e:xh'
while getopts $options option
do
    case $option in
        d) directory="${OPTARG}";;
        p) passphrase="${OPTARG}";;
        e) encryption_algorithm="${OPTARG}";;
        x) mode="extract";;
        h) show_usage; exit 2;;
        \?) echo "Invalid option"
            exit 4;;
    esac
done
shift $((OPTIND-1))
# Ask for passphrase if not provided
if [ -z ${passphrase} ]; then
  read -s -p "Passphrase (not echoed): " passphrase
  echo
fi
# Loop over the output files, determine capacity, then read that many
# bytes from the input and encode them in the output file.
# If data is remaining after all files have been processed, flag this
# as an error.
echo "Finding files..." >&2
files=$( find_files "${directory}" )
if [ "${mode}" = "embed" ]; then
  echo "Embedding" >&2
  # Determine input file to handle; no input file parameter means stdin and we copy that to a tmp file
  if [ $# -gt 0 ]; then
    input_filename="${1}"
  else
    tmpfile=$( mktemp )
    input_filename="${tmpfile}"
    cat >"${tmpfile}"
  fi
  echo "Determining file size..." >&2
  total_size_in_bytes=$( get_file_size_in_bytes "${input_filename}" )
  echo "File size to embed is ${total_size_in_bytes} bytes" >&2
  export size_encoded_so_far_in_bytes=0
  exec 4<"${input_filename}"
  size_encoded_so_far_in_bytes=$(
    echo "${files}" | while read file; do
      echo "Determining file capacity for ${file}" >&2
      file_capacity_in_bytes=$( get_file_capacity_in_bytes "${file}" )
      echo "File: ${file} has capacity ${file_capacity_in_bytes}" >&2
      head -c ${file_capacity_in_bytes} <&4 | steghide embed -p "${passphrase}" -cf "${file}" -e ${encryption_algorithm} >&2
      size_encoded_so_far_in_bytes=$(( ${size_encoded_so_far_in_bytes} + ${file_capacity_in_bytes} ))
      echo "size_encoded_so_far_in_bytes is ${size_encoded_so_far_in_bytes}" >&2
      echo "${size_encoded_so_far_in_bytes}"
      if [ ${size_encoded_so_far_in_bytes} -ge ${total_size_in_bytes} ]; then
        echo "Last output file used: ${file}" >&2
        exit 0
      fi
    done | tail -1
  )
  echo "Encoded bytes: ${size_encoded_so_far_in_bytes}" >&2
  # Clean up:
  clean_up
  # Error check:
  if [ ${size_encoded_so_far_in_bytes} -lt ${total_size_in_bytes} ]; then
    echo "Not all ${total_size_in_bytes} bytes were embedded but only ${size_encoded_so_far_in_bytes}." >&2
    exit 1
  fi
elif [ "${mode}" = "extract" ]; then
  if [ $# -gt 0 ]; then
    output_filename="${1}"
    exec 1>"${output_filename}"
    echo "Extracting embedded content to file ${output_filename}" >&2
  else
    echo "Extracting embedded content to standard output" >&2
  fi
  echo "${files}" | while read file; do
    echo "Looking for embedded content in ${file}..." >&2
    if ! steghide extract -p "${passphrase}" -sf "${file}" -xf - 2>/dev/null; then
      echo "No more content found embedded in ${file}. Finished." >&2
      exit 0
    fi
  done
else
  echo "Unknown mode ${mode}" >&2
  exit 3
fi
